<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CLO Article â†’ Structured Data</title>
<!-- Tesseract runs fully in the browser (private/local) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.2/dist/tesseract.min.js"></script>
<style>
  :root { --bg:#f6f7fb; --card:#fff; --ink:#222; --muted:#666; --brand:#2563eb; --ok:#16a34a; --warn:#d97706; }
  *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  .wrap{max-width:980px;margin:40px auto;padding:0 16px}
  .card{background:var(--card);border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.06);padding:20px}
  h1{margin:0 0 14px;font-size:26px}
  p.helper{color:var(--muted);margin:0 0 14px}
  .grid{display:grid;gap:18px}
  @media(min-width:900px){.grid{grid-template-columns:320px 1fr}}
  .uploader{border:1px dashed #cbd5e1;border-radius:12px;padding:14px;text-align:center;background:#fafafa}
  .uploader input{width:100%}
  .preview{border-radius:12px;overflow:hidden;background:#fff;border:1px solid #e5e7eb}
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 14px;border-radius:10px;border:none;background:var(--brand);color:#fff;cursor:pointer;font-weight:600}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.secondary{background:#0ea5e9}
  .btn.copy{background:#6b7280}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .progress{height:10px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:100%;width:0;background:var(--ok);transition:width .2s ease}
  .section h3{margin:18px 0 8px}
  table{width:100%;border-collapse:collapse;border:1px solid #e5e7eb;border-radius:10px;overflow:hidden}
  th,td{padding:10px;border-bottom:1px solid #e5e7eb;text-align:left;font-size:14px}
  th{background:#f8fafc}
  tr:last-child td{border-bottom:none}
  .raw{background:#0b1220;color:#e5edff;border-radius:12px;padding:12px;max-height:240px;overflow:auto}
</style>
</head>
<body>
<div class="wrap">
  <h1>ðŸ“„ CLO Article â†’ Structured Data</h1>
  <p class="helper">Upload an article screenshot. Everything runs locally in your browser. Output shows deal info + tranche table you can paste into your tool.</p>

  <div class="grid">
    <!-- LEFT: image + OCR -->
    <div class="card">
      <div class="uploader">
        <input id="file" type="file" accept="image/*" />
        <p class="muted" style="margin:10px 0 0">Tip: crop to the article text/table area for best accuracy.</p>
      </div>
      <div style="height:14px"></div>
      <div class="row">
        <button id="runBtn" class="btn" disabled>Run OCR & Extract</button>
        <button id="copyJsonBtn" class="btn copy" disabled>Copy JSON</button>
      </div>
      <div style="height:12px"></div>
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div style="height:12px"></div>
      <div id="imgBox" class="preview"></div>
      <div style="height:12px"></div>
      <details>
        <summary class="muted">Show raw OCR text</summary>
        <pre id="raw" class="raw mono"></pre>
      </details>
    </div>

    <!-- RIGHT: structured output -->
    <div class="card section">
      <h3>Structured Deal Info</h3>
      <div id="deal" class="mono"></div>

      <h3 style="margin-top:22px">Tranche Table</h3>
      <div id="tranches"></div>
    </div>
  </div>
</div>

<script>
const fileInput = document.getElementById('file');
const runBtn = document.getElementById('runBtn');
const copyBtn = document.getElementById('copyJsonBtn');
const bar = document.getElementById('bar');
const imgBox = document.getElementById('imgBox');
const rawEl = document.getElementById('raw');
const dealEl = document.getElementById('deal');
const tranchesEl = document.getElementById('tranches');

let lastResult = null;

fileInput.addEventListener('change', () => {
  dealEl.textContent = '';
  tranchesEl.innerHTML = '';
  rawEl.textContent = '';
  bar.style.width = '0%';
  copyBtn.disabled = true;

  const f = fileInput.files[0];
  if (!f) { runBtn.disabled = true; imgBox.innerHTML=''; return; }
  runBtn.disabled = false;

  const img = document.createElement('img');
  img.style.maxWidth = '100%';
  img.style.display = 'block';
  img.alt = 'preview';
  imgBox.innerHTML = '';
  imgBox.appendChild(img);
  const reader = new FileReader();
  reader.onload = e => img.src = e.target.result;
  reader.readAsDataURL(f);
});

runBtn.addEventListener('click', async () => {
  const f = fileInput.files[0];
  if (!f) return;

  runBtn.disabled = true;
  dealEl.textContent = 'Running OCRâ€¦';
  tranchesEl.innerHTML = '';
  rawEl.textContent = '';
  bar.style.width = '5%';

  try {
    const worker = await Tesseract.createWorker('eng', 1, { logger: m => {
      if (m.status === 'recognizing text' && m.progress != null) {
        bar.style.width = Math.max(8, Math.round(m.progress*100)) + '%';
      }
    }});
    const { data } = await worker.recognize(f);
    await worker.terminate();

    const text = (data.text || '').replace(/\u00A0/g,' ').trim();
    rawEl.textContent = text;
    bar.style.width = '100%';

    const structured = extractCLO(text);
    lastResult = structured;

    renderDeal(structured);
    renderTable(structured.tranches || []);
    copyBtn.disabled = false;
  } catch (e) {
    dealEl.textContent = 'OCR failed. Try cropping the image tighter to the text/table.';
    console.error(e);
    runBtn.disabled = false;
  }
});

copyBtn.addEventListener('click', async () => {
  if (!lastResult) return;
  const pretty = JSON.stringify(lastResult, null, 2);
  await navigator.clipboard.writeText(pretty);
  copyBtn.textContent = 'Copied âœ“';
  setTimeout(()=> copyBtn.textContent = 'Copy JSON', 1200);
});

/* ---------- Parsing logic (heuristic but robust for CLO articles) ---------- */

function extractCLO(text) {
  const t = normalize(text);
  const lines = t.split('\n').map(s=>s.trim()).filter(Boolean);

  // Issuer / title: look for first line with 'CLO' and a number or issuer keywords
  let issuer = findFirstMatch(lines, /(CLO\s*\d+[^:\n]*|[A-Z][A-Za-z0-9&.\- ]+ CLO[^:\n]*)/i);

  // Deal size: $406 million / $4.2 billion
  let dealSizeRaw = matchFirst(t, /\$?\s*([\d,.]+)\s*(million|mn|m|billion|bn|b)\b/i);
  let dealSizeMillions = null;
  if (dealSizeRaw) {
    const num = parseFloat(dealSizeRaw[1].replace(/,/g,''));
    const unit = dealSizeRaw[2].toLowerCase();
    dealSizeMillions = (unit.startsWith('b')) ? num*1000 : num;
  }

  // Close date
  const closeDate = matchDate(t, /(expected to close on|close(?:s|d)? on|closing on|close date[: ]+)/i);

  // Non-call end date
  const nonCallEnd = matchDate(t, /(non[- ]?call (?:period )?(?:end(?:ing)?|to|until)|non[- ]?call[: ]+)/i);

  // Reinvestment end (often "runs off on the payment date in Oct 2030" or "through October 2030")
  const reinvEnd = matchMonthYear(t, /(reinvestment (?:period )?(?:runs|to|through|until|end(?:s|ing)?)\b[^.\n]*)/i);

  // Legal final maturity
  const maturity = matchMonthYear(t, /(legal final maturity|final maturity|stated maturity|maturity\b[^.\n]*)/i);

  // Tranche table rows
  const tranches = extractTranches(lines);

  return {
    issuer: issuer || null,
    deal_size_millions: (dealSizeMillions!=null) ? round2(dealSizeMillions) : null,
    close_date: closeDate || null,
    non_call_end_date: nonCallEnd || null,
    reinvestment_end_date: reinvEnd || null,
    final_maturity: maturity || null,
    tranches
  };
}

function normalize(s){
  return s
    .replace(/\r/g,'')
    .replace(/[|]/g,' ')
    .replace(/â€”/g,'-')
    .replace(/\s{2,}/g,' ')
    .replace(/([\n])\s+/g,'$1')
    .trim();
}
function findFirstMatch(lines, regex){
  for (const ln of lines) {
    const m = ln.match(regex);
    if (m) return m[0].trim();
  }
  return null;
}
function matchFirst(text, regex){
  const m = text.match(regex);
  return m || null;
}
function matchDate(text, anchorRegex){
  // Full month name with day + year: October 17, 2027  | Oct. 17, 2027
  const months = "(January|February|March|April|May|June|July|August|September|October|November|December|Jan\\.?|Feb\\.?|Mar\\.?|Apr\\.?|May|Jun\\.?|Jul\\.?|Aug\\.?|Sept?\\.?|Oct\\.?|Nov\\.?|Dec\\.?)";
  const dateRe = new RegExp(anchorRegex.source + ".*?(" + months + "\\s+\\d{1,2},\\s*\\d{4})","i");
  const m = text.match(dateRe);
  return m ? cleanMonth(m[1]) : null;
}
function matchMonthYear(text, anchorRegex){
  // Month + year without day: October 2030 | Oct. 2030
  const months = "(January|February|March|April|May|June|July|August|September|October|November|December|Jan\\.?|Feb\\.?|Mar\\.?|Apr\\.?|May|Jun\\.?|Jul\\.?|Aug\\.?|Sept?\\.?|Oct\\.?|Nov\\.?|Dec\\.?)";
  const myRe = new RegExp(anchorRegex.source + ".*?(" + months + "\\s+\\d{4})","i");
  const m = text.match(myRe);
  return m ? cleanMonth(m[1]) : null;
}
function cleanMonth(s){
  return s.replace(/\bSept\.\b/i,'Sep')
          .replace(/\bSept\b/i,'Sep')
          .replace(/\\./g,'')
          .replace(/\s+/g,' ')
          .trim();
}
function round2(n){ return Math.round(n*100)/100; }

function extractTranches(lines){
  const classes = ['A-1','A-2','A-3','A','AA','AAA','B','C','D','E','F','G','Sub Notes','Sub','Equity'];
  const classRe = /^(A-1|A-2|A-3|A-4|A|B|C|D|E|F|G|Sub Notes|Sub|Equity)\b/i;

  const rows = [];
  for (const ln0 of lines) {
    const ln = ln0.replace(/\s{2,}/g,' ').trim();
    if (!classRe.test(ln)) continue;

    // Try to capture: Class | Size ($M) | Expected rating | Coupon | Price | Discount margin
    // Examples:
    // "A-1 256.00 AAA S+125 100 125"
    // "F 6.00 B- S+784 99 800"
    const m = ln.match(/^(A-1|A-2|A-3|A-4|A|B|C|D|E|F|G|Sub Notes|Sub|Equity)\s+([\d,.]+)\s+([A-Z]{1,3}(?:[-+])?|NR)\s+(S\+\d+|SOFR\+\d+|3mL\+\d+|Fixed|Fixe?d|N\/A|-|â€”)?\s+(\d{1,3}(?:\.\d+)?)?\s+(\d{1,4})?$/i);

    // If the strict regex fails (OCR noise), fall back to looser tokenization
    if (m) {
      rows.push({
        class: m[1],
        size_millions: Number(m[2].replace(/,/g,'')),
        expected_rating: m[3] || null,
        coupon: (m[4] && !/^-|â€”|N\/A$/i.test(m[4])) ? m[4] : null,
        price: m[5] ? Number(m[5]) : null,
        discount_margin_bps: m[6] ? Number(m[6]) : null
      });
      continue;
    }

    const toks = ln.split(/\s+/);
    const cls = toks.shift();
    // Heuristic mapping for noisy OCR rows
    let size = takeFirstNumber(toks);
    let rating = takeRating(toks);
    let coupon = takeCoupon(toks);
    let price = takeFirstNumber(toks);
    let dm = takeFirstNumber(toks);

    if (size != null || rating || coupon || price != null || dm != null) {
      rows.push({
        class: cls,
        size_millions: size,
        expected_rating: rating || null,
        coupon: coupon || null,
        price: price,
        discount_margin_bps: dm
      });
    }
  }
  return rows;
}

function takeFirstNumber(arr){
  for (let i=0;i<arr.length;i++){
    const x = arr[i].replace(/[,]/g,'');
    if (/^\d+(\.\d+)?$/.test(x)){
      arr.splice(i,1);
      return Number(x);
    }
  }
  return null;
}
function takeRating(arr){
  for (let i=0;i<arr.length;i++){
    const x = arr[i];
    if (/^(AAA|AA|A|BBB-|BBB|BB-|BB|B-|B|NR)$/i.test(x)){
      arr.splice(i,1);
      return x.toUpperCase();
    }
  }
  return null;
}
function takeCoupon(arr){
  for (let i=0;i<arr.length;i++){
    const x = arr[i];
    if (/^(S\+\d{2,3}|SOFR\+\d{2,3}|3mL\+\d{2,3}|Fixed|Fixe?d)$/i.test(x)){
      arr.splice(i,1);
      return x.toUpperCase();
    }
  }
  return null;
}

/* ---------- Renderers ---------- */
function renderDeal(obj){
  const out = {
    issuer: obj.issuer || null,
    deal_size_millions: obj.deal_size_millions,
    close_date: obj.close_date,
    non_call_end_date: obj.non_call_end_date,
    reinvestment_end_date: obj.reinvestment_end_date,
    final_maturity: obj.final_maturity
  };
  dealEl.textContent = JSON.stringify(out, null, 2);
}
function renderTable(rows){
  if (!rows || !rows.length){
    tranchesEl.innerHTML = '<p class="muted">No tranche rows detected. If the table is small in the screenshot, try zooming/cropping and rerun.</p>';
    return;
  }
  const thead = `
    <thead><tr>
      <th>Class</th><th>Size ($M)</th><th>Expected Rating</th>
      <th>Coupon</th><th>Price</th><th>Discount Margin</th>
    </tr></thead>`;
  const body = rows.map(r=>`
    <tr>
      <td>${escape(r.class)}</td>
      <td>${r.size_millions ?? ''}</td>
      <td>${escape(r.expected_rating ?? '')}</td>
      <td>${escape(r.coupon ?? '')}</td>
      <td>${r.price ?? ''}</td>
      <td>${r.discount_margin_bps ?? ''}</td>
    </tr>`).join('');
  tranchesEl.innerHTML = `<table>${thead}<tbody>${body}</tbody></table>`;
}
function escape(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
</script>
</body>
</html>
